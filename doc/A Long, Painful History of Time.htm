<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15">
   <meta name="Author" content="Erik Naggum">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (X11; I; Linux 2.2.12 i686) [Netscape]">
   <meta name="Description" content="The Common Lisp concept of time, and how it relates to scientific time and political time.">
   <title>A Long, Painful History of Time</title>
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#FF0000" alink="#00B200">

<center>
<h1>
<br>
<br>
<font color="#000000">The Long, Painful History of Time</font></h1></center>

<p>&nbsp;
<center>
<p><b><font color="#000000">Erik Naggum</font></b>
<br><font color="#000000">Naggum Software</font>
<br><font color="#000000">Oslo, Norway</font>
<br>&nbsp;
<p>1999-10-11</center>

<p><br>
<center>
<h3>
<font color="#000000">ABSTRACT</font></h3></center>

<blockquote>
<blockquote><font color="#000000">The programming language Common Lisp
offers a few functions to support the concept of time as humans experience
it, including <font size=-1><tt>GET-UNIVERSAL-TIME</tt>,</font> <tt><font size=-1>ENCODE-UNIVERSAL-TIME</font></tt>,
<tt><font size=-1>DECODE-UNIVERSAL-TIME</font></tt>,
and <tt><font size=-1>GET-DECODED-TIME</font></tt>. These functions assume
the existence of a timezone and a daylight saving time regime, such that
they can support the usual expression of time in the environment in which
a small number of real-life applications run. The majority of applications,
however, need more support to be able to read and write dates and times,
calculate with time, schedule events at specific clock times daily, and
work with several time zones and daylight saving time regimes. This paper
discusses some of the problems inherent in processing time suitable to
humans and describes a solution employed by the author in a number of applications,
the <tt><font size=-1>LOCAL-TIME</font></tt> concept.</font></blockquote>
</blockquote>

<h2>
<br>
<font color="#000000">Introduction</font></h2>
The measurement of time has a very long history, dating back to the first
records of human civilization.&nbsp; Yet, the archeological evidence suggests
that the concept of time evolved no further than ordinary human needs,
and any notion of time remained confined to a fairly short time frame,
such as a lifetime past and future.&nbsp; Expressions of measurements of
time were brief and imprecise, rife with the numerous and nefarious assumptions
humans bring into their communication, consistent with our tendency to
suppress information believed to be redundant.
<p>For instance, everyone knows which century they are in or that some
two-digit year refers to.&nbsp; Until computers came along, the assumptions
held by people were either recoverable from the context or shared by contemporary
communicators.&nbsp; After computers came to store information for us,
we still held onto the context as if the computers were as able to recover
it as we are.&nbsp; Quite obviously, they aren't, and in about three months,
we will see whether other humans were indeed able to recover the context
left unstated by other humans when they wrote down their dates with two
digits and assumed it would never be a problem.&nbsp; The infamous Y2K
problem is one of the few opportunities mankind will get to tally the costs
of lack of precision in our common forms of communication.&nbsp; The lesson
learned will not be that our notations of time need to be precise and include
their context, unless the general public stops refusing to be educated
in the face of dire experience.&nbsp; That so much attention has been granted
this silly problem is fortunate for those of us who argue against legacy
notations of time.&nbsp; However, the inability of most people to deal
with issues of such extraordinary importance when they look "most harmless"
means that those who do understand them must be inordinately careful in
preparing their information such that loss of real information can be minimized.
<p>The basic problem with time is that we need to express both time and
place whenever we want to place some event in time and space, yet we tend
to assume spatial coordinates even more than we assume temporal coordinates,
and in the case of time in ordinary communication, it is simply left out
entirely.&nbsp; Despite the existence of time zones and strange daylight
saving time regimes around the world, most people are blithely unaware
of their own time zone and certainly of how it relates to standard references.&nbsp;&nbsp;
Most people are equally unaware that by choosing a notation that is close
to the spoken or written expression of dates, they make it meaningless
to people who may not share the culture, but can still read the language.&nbsp;
It is unlikely that people will change enough to put these issues to rest,
so responsible computer people need to address the issues and resist the
otherwise overpowering urge to abbreviate and drop context.
<p>This paper is almost all about how we got ourselves into trouble by
neglecting to think about time frames longer than a human lifetime, how
we got all confused by the difference between time as an orderly concept
in science and a mess in the rest of human existence, and how we have missed
every opportunity to fix the problems.&nbsp; This paper proposes a fix
to the most glaring problems in a programming language that should not
have been left without a means to express time for so long.
<h2>
<br>
Scientific Time</h2>
How long does it take the earth to face the Sun at the same angle?&nbsp;
This simple question has a definite and fairly simple scientific answer,
and from this answer, we can work out a long list of answers about what
time is and how we want to deal with astronomical events.&nbsp; The SI
units (Système International d'Unités), probably better known as "metric
units", define the second as the fundamental unit of time, and this, too,
has a very good scientific definition.&nbsp; Time progresses continuously
and is only chopped up into units for human convenience.&nbsp; Agreement
on a single reference point within a scientific community has always been
easy, and it is useful to count basic units, like days in the (Modified)
Julian Day system, or seconds since some arbitrary epoch in computers.
<p>Scientific time also lends itself to ease of computation; after all,
that is what we do with it.&nbsp; For instance, we have a world-wide standard
for time, called the Coordinated Universal Time, or <tt><font size=-1>UTC.</font></tt>&nbsp;
(The <tt><font size=-1>C</font></tt> used to be subscripted, <tt><font size=-1>UT<sub>C</sub></font></tt>,
just like the digits in <tt><font size=-1>UT<sub>0</sub></font></tt> and
<tt><font size=-1>UT<sub>1</sub></font></tt>,
which are universal time concepts with slightly different reference points,
but "<tt><font size=-1>UTC</font></tt>" has become the preferred form.)&nbsp;
Scientific time naturally has origin 0, as usual with scientific measures,
even though the rest of human time notations tend to have origin 1, the
problems of which will be treated below.
<p>Most computer-related references to time deal with periods of time,
which lend themselves naturally to use scientific time, and therefore,
it makes sense to most programmers to treat the period of time from some
epoch until some other time to be the best way to express said other time.&nbsp;&nbsp;
This is the path taken by Common Lisp in its <tt><font size=-1>UNIVERSAL-TIME</font></tt>
concept, with time <tt><font size=-1>0 </font></tt>equal to <tt><font size=-1>1900-01-01
00:00:00 UTC,</font></tt> and the Unix time concept, with time <tt><font size=-1>0</font></tt>
equal to <tt><font size=-1>1970-01-01 00:00:00 UTC</font></tt>.&nbsp;&nbsp;
This approach works well as long as the rules for converting between relative
and absolute time are stable.&nbsp; As it turns out, they are not.
<p>Not all languages and operating systems use this sensible an approach.&nbsp;
Some have used local time as the point of reference, some use decoded local
time as the reference, and some use hardware clocks that try to maintain
time suitable for direct human consumption.&nbsp; There is no need to make
this issue more complex than it already is, so they will not be granted
any importance.
<br>&nbsp;
<h2>
Political Time</h2>
How long does it take for the clock to show the same value?&nbsp; The answer
to this question is only weakly related to the time the planet takes to
make a complete rotation.&nbsp; Normally, we would say the political rotation
takes 24 hours, just like the scientific, but one day out of the year,
it takes only 23 hours, and another day out of the year, it takes 25 hours,
thanks to the wonders of daylight saving time.&nbsp; Which days these are
is a decision made by politicians.&nbsp; It used to be made by the military
to conserve fuel, but was taken over by labor unions as a means to get
more daylight in the workers' spare time, and most countries have gone
through an amazing list of strange decision-making in this area during
this century.&nbsp; Short of coming to their senses and abolishing the
whole thing, we might expect that the rules for daylight saving time will
remain the same for some time to come, but there is no guarantee.&nbsp;
(We can only be glad there is no daylight loan time, or we would face decades
of too much daylight, only to be faced with a few years of total darkness
to make up for it.)
<p>Political time is closely related to territory, power, and collective
human irrationality.&nbsp; There is no way you can know from your location
alone which time zone applies at some particular point on the face of the
earth: you have to ask the people who live there what they have decided.&nbsp;
This is very different from scientific time, which could tell you with
great ease and precision what the mean sidereal time at some location should
be.&nbsp; In some locations, this is as much as three hours off from what
the local population has decided, or has had decided for them.&nbsp; The
Sun is in zenith at noon at very few places on earth, instead being eclipsed
or delayed by political decisions where the randomness never ends.
<p>Yet, it is this political time that most people want their computers
to produce when they ask for the date or the time of day, so software will
have to comply with the randomness and produce results consistent with
political decisions.&nbsp; The amount of human input into this process
is very high, but that is the price we have to pay for our willingness
to let politicians dictate the time.&nbsp; However, once the human input
has been provided, it is annoying to find that most programming languages
and supporting systems do not work with more than one timezone at a time,
and consequently do not retain timezone information with time data.
<p>The languages we use tend to shape the ideas we can talk about.&nbsp;
So, too, the way we write dates and times influence our concepts of time,
as they were themselves influenced by the way somebody thought about time
a long time ago.&nbsp; Calendars and decisions like which year is the first,
when the year starts, and how to deal with astronomical irregularities
were made so long ago that the rationale for them has not survived in any
form, but we can still look at what we have and try to understand.&nbsp;
In solving the problem of dealing with time in computers, a solid knowledge
of the legacy we are attending to is required.
<br>&nbsp;
<h2>
Notations for Time</h2>
The way we write down time coordinates appears to have varied little over
the years in only one respect: we tend to write them differently depending
on the smallest perceived unit of time that needs to be communicated.&nbsp;
For instance, it seems sufficiently redundant to include <i>AD</i> or <i>BC</i>
in the dates of birth of contemporary people that they are always omitted.&nbsp;
Should some being with age >2000 years come to visit us, it is also unlikely
that writing its date of birth correctly would be a pressing concern.&nbsp;&nbsp;
However, we tend to include these markers for the sign of the year when
the possibility of ambiguity reaches a certain level as determined by the
reader.&nbsp; This process is itself fraught with ambiguity and inconsistency,
but when computers need to deal with dates this far back, it does not seem
worthwhile to calculate them in terms of standard reference points, so
we can ignore the problem for now, but may need to deal with it if a system
of representation is sufficiently useful to be extended to the ancient
past.
<p>Not only do we omit information that is deemed redundant, it is not
uncommon for people to omit information out of sheer laziness.&nbsp; A
particularly flagrant example of the omission of information relative to
the current time is the output from the Unix <tt><font size=-1>ls</font></tt>
program which lists various information about files.&nbsp; The customary
date and time format in this program is either month-day-hour-minute or
month-day-year.&nbsp; The cutoff for tolerable precision is six months
ago, which most implementations approximate with 180 days.&nbsp; This reduction
in precision appears to have been motivated by horizontal space requirements,
a necessary move after wasting a lot of space on irrelevant information,
but for some reason, precision in time always suffers when people are short
of space.
<p>The infamous <tt><font size=-1>Y2K</font></tt> problem, for instance,
is said to have started when people wanted to save two columns on punched
cards, but there is strong evidence of other, much better alternatives
at the time, so the decision to lose the century was not predicated on
the need for space, but rather on the culturally acceptable loss of information
from time coordinates.&nbsp; The details of this mess are sufficiently
involved to fill a separate paper, so the conclusion that time loses precision
first when in need or perceived need of space should be considered supported
by the evidence.
<h3>
Natural-Language Notations</h3>
People tend to prefer words to numbers, and go out of their way to name
things.&nbsp; Such names are frequently symbolic because they are inherently
arbitrary, which implies that we can learn much from studying what people
call numbers.&nbsp; (French has a number which means "arbitrarily many":
36, used just like English "umpteen", but it is fascinating that a number
has meaning like that.&nbsp; Other numbers with particular meaning include
69, 666, and 4711.&nbsp; The number 606 has been used to refer to arsphenamine,
because it was the 606th compound tested by Paul Ehrlich to treat syphilis.)&nbsp;
In the present context, the names of the Roman months have been adopted
by all Western languages, while the names of days of the week have more
recent and diverse names, probably because weeks are a fairly recent concept.
<p>Using names for numeric entities complicates processing a natural language
specification of time tremendously, yet this is what people seem more comfortable
with.&nbsp; In some cultures, months have only names, while in others,
they are nearly always written as numbers.&nbsp; The way the names of months
and the days of the week are abbreviated varies from language to language,
as well, so software that wants to be international needs to maintain a
large repository of names and notations to cater to the vanity of human
users.&nbsp; However, the names are not the worst we have to deal with
in natural language notations.
<p>Because dates and times are frequently spoken and because the written
forms are often modeled after the spoken, we run into the problem of ordering
the elements of time and the omission of perceived redundancy becomes a
much more serious problem, because each language and each culture have
handled these problems so differently.&nbsp; The orders in use for dates
are
<ul>
<li>
year-month-day</li>

<li>
day-month-year</li>

<li>
month-day-year</li>

<li>
day-month</li>

<li>
month-day</li>

<li>
year-month</li>

<li>
month-year</li>
</ul>
As long as the year is zero or greater than 31 or the day greater than
12, it is usually possible to disambiguate these orders, but we are about
to experience renewed problems in 2001, when the year will probably be
still be written with two digits by some people regardless of the experience
of mankind as a whole at <tt><font size=-1>2000-01-01 00:00:00</font></tt>.&nbsp;
We live in interesting times, indeed.
<p>Time is fortunately specified with a uniform hour-minute-second order,
but the assumption of either <tt><font size=-1>AM</font></tt> or <tt><font size=-1>PM</font></tt>
even in cultures where there is no custom for their specification provides
us with an ambiguity that computers are ill equipped to deal with.&nbsp;
This and other historic randomness will be treated in full below.
<p>Most of the time people refer to is in their immediate vicinity, and
any system intended to capture human-friendly time specifications will
need to understand relative times, such as "yesterday", "this time tomorrow",
"two hours ago", "in fifteen minutes".&nbsp; All of these forms vary considerably
from culture to culture and from language to language, making the process
of reading these forms as input non-trivial.&nbsp; The common forms of
expression for periods of time is also fuzzy in human communication, with
units that fail to convert to intervals of fixed length, but instead are
even more context-sensitive than simple points in time.
<h3>
Language-Neutral Notations</h3>
Various attempts have been made to overcome the problems of human-to-human
forms of communication between human and machine and in machine-to-machine
communication.&nbsp; Machine-to-machine communication generally falls into
one of three categories:
<ol>
<li>
Naïve binary</li>

<li>
Formatted or encoded binary</li>

<li>
Character sequences (text)</li>
</ol>
Binary formats in general suffer from a huge number of problems that there
is little value in&nbsp; discussing here, but it is worth noting that a
binary format that is as robust as a textual format is frequently just
as verbose as a textual format, so in the interest of robustness and legibility,
this discussion will restrict itself to textual formats
<p>Obviously, a language-neutral notation will have to consist of standardized
elements and possibly codes.&nbsp; Fortunately, a standard like this already
exists: <tt><font size=-1>ISO 8601</font></tt>.&nbsp; Since all the work
with a good language-neutral notation has already been done, it would be
counter-productive in the extreme to reinvent one.&nbsp; However, <tt><font size=-1>ISO
8601</font></tt> is fairly expensive from the appropriate sources and also
chock full of weird options, like most compromise standards, so in the
interest of solving some problems with its use, only the extended format
of this standard will be employed in this paper.
<p>A language-neutral notation will need to satisfy most, if not all, of
the needs satisfied by natural language notations, but some latitude is
necessary when dealing with relative times -- after all, the purpose of
the language-neutral notation is to remove ambiguity and make assumptions
more if not completely explicit.&nbsp; <tt><font size=-1>ISO 8601</font></tt>
is sufficient to cover these needs:
<ul>
<li>
absolute positions in time</li>

<li>
duration</li>

<li>
period with absolute start and end</li>

<li>
period with absolute start or end and duration</li>
</ul>
The needs not covered are mostly related to user convenience with respect
to the present and absolute positions in time in its immediate vicinity.
<i>E.g.</i>,
the omission of the date when referring to yesterday, tomorrow, the most
recent occurrence of a time of day, and the forthcoming occurrence of a
time of day.&nbsp; To make this more convenient, the notation employed
in the <tt><font size=-1>LOCAL-TIME</font></tt> concept described below
has special syntax for these relative times.
<p>The full, extended format of <tt><font size=-1>ISO 8601</font></tt>
is as follows:
<blockquote><tt><font size=-1>1999-10-11T11:10:30,5-07:00</font></tt></blockquote>
The elements are, in order:
<ol>
<li>
the year with four digits</li>

<li>
a hyphen (omitted in the basic format)</li>

<li>
the month with two digits</li>

<li>
a hyphen (omitted in the basic format)</li>

<li>
the day of month with two digits</li>

<li>
the letter T to separate date and time</li>

<li>
the hour in the 24-hour system with two digits</li>

<li>
a colon (omitted in the basic format)</li>

<li>
the minute with two digits</li>

<li>
a colon (omitted in the basic format)</li>

<li>
the second with two digits</li>

<li>
a comma</li>

<li>
the fraction of the second with unlimited precision</li>

<li>
a plus sign or hyphen (minus) to indicate sign of time zone</li>

<li>
the hours of the time zone with two digits</li>

<li>
a colon (omitted in the basic format)</li>

<li>
the minutes of the time zone with two digits</li>
</ol>
The rules for omission of elements are quite simple.&nbsp; Elements from
the time of day may be omitted from the right and take their immediately
preceding delimiter with them.&nbsp; Elements from the date may be omitted
from the left, but leave the immediately following delimiter behind.&nbsp;
When the year is omitted, it is replaced by a hyphen.&nbsp; Elements of
the date may also be omitted from the left, provided no other elements
follow, in which case they take their immediately preceding delimiter with
them.&nbsp; The letter T is omitted if the whole of the time of day or
the whole of the date are omitted.&nbsp; If an element is omitted from
the left, it is assumed to be the current value.&nbsp; (In other words,
omitting the century is really dangerous, so I have even omitted the possibility
of doing so.)&nbsp; If an element is omitted from the right, it is assumed
to cover the whole range of values and thus be indeterminate.
<p>Every element in the time specification needs to be within the normal
bounds.&nbsp; There is no special consideration for leap seconds, although
some might want to express them using this standard.
<p>A duration of time has a separate notation entirely, as follows:
<blockquote><tt><font size=-1>P1Y2M3DT4H5M6S</font></tt>
<br><tt><font size=-1>P7W</font></tt></blockquote>
The elements are, in order:
<ol>
<li>
the letter P to indicate a duration</li>

<li>
the number of years</li>

<li>
the letter Y to indicate years</li>

<li>
the number of months</li>

<li>
the letter M to indicate months</li>

<li>
the number of days</li>

<li>
the letter D to indicate days</li>

<li>
the letter T to separate dates from times</li>

<li>
the number of hours</li>

<li>
the letter H to indicate hours</li>

<li>
the number of minutes</li>

<li>
the letter M to indicate minutes</li>

<li>
the number of seconds</li>

<li>
the letter S to indicate seconds</li>
</ol>
or for the second form, usually used alone
<ol>
<li>
the letter P to indicate a duration</li>

<li>
the number of weeks</li>

<li>
the letter W to indicate weeks</li>
</ol>
Any element (number) may be omitted from this specification and if so takes
its following delimited with it.&nbsp; Unlike the absolute time format,
there is no requirement on the number of digits, and thus no requirement
for leading zeros.
<p>A period of time is indicated by two time specifications, at least one
of which has to be absolute, separated by a single solidus (slash), and
has the general forms as follows:
<blockquote>start<tt><font size=-1>/</font></tt>end
<br>start<tt><font size=-1>/</font></tt>duration
<br>duration<tt><font size=-1>/</font></tt>end</blockquote>
the end form may have elements of the date omitted from the left with the
assumption that the default is the corresponding value of the element from
the start form.&nbsp; Omissions in the start form follow the normal rules.
<p>The standard also has specifications for weeks of the year and days
of the week, but these are used so rarely and are æsthetically displeasing
so are gracefully elided from the presentation.
<p>When discussing the read/write syntax of the <tt><font size=-1>LOCAL-TIME</font></tt>
concept below, the above formats will be employed with very minor modifications
and extensions.
<br>&nbsp;
<h2>
Geography</h2>
It is amusing that when people specify a time, they tend to forget that
they looked at their watches or asked other time-keeping devices at a particular
geographic location.&nbsp; The value they use for "current time" is colored
by this location so much that the absence of a location at which we have
the current time, renders it completely useless -- it could be specified
in any one of the about 30 (semantically different) timezones employed
around the planet.&nbsp; This is particularly amusing with statements you
find on the web:
<blockquote><tt><font size=-1>This page was updated 7/10/99 2:00 AM.</font></tt></blockquote>
This piece of information is amazingly useless, yet obviously not so to
the person who knows where the machine is located and who wrote it in the
first place.&nbsp; Only by monitoring for changes to this statement does
it have any value at all.&nbsp; Specifications of time often has this purpose,
but the belief that they carry information, too, is quite prevalent.&nbsp;
The only thing we know about this time specification is that it was made
in the past, which may remove most of the ambiguity, but not quite all
-- it could be <tt><font size=-1>1999-07-10.</font></tt>
<p>The geographical origin of a time specification is in practice necessary
to understand it.&nbsp; Even with the standard notation described above,
people will want to know the location of the time.&nbsp; Unfortunately,
there is no widely adopted standard for geographical locations.&nbsp; Those
equipped with <tt><font size=-1>GPS</font></tt> units may use <tt><font size=-1>ICBM
</font></tt>or
grid coordinates, but this is almost as devoid of meaning as raw <tt><font size=-1>IP</font></tt>
addresses on the Internet.&nbsp; Above all, geography is even more rife
with names and naming rules that suffer from translation than any other
information that cries for a precise standard.
<p>Time zones therefore double as indicators of geographical location,
much to the chagrin of anyone who is not from the same location, because
they use names and abbreviations of names with local meaning.&nbsp; Of
course.&nbsp; Also, the indication of the daylight saving time in the timezone
is rather amusing in the probably unintentional complexity they introduce.&nbsp;
For instance, the Middle or Central European Time can be abbreviated <tt><font size=-1>MET</font></tt>
or <tt><font size=-1>CET</font></tt>, but the "summer time" as it is called
here is one of <tt><font size=-1>MEST</font></tt>, <tt><font size=-1>CEST</font></tt>,
<tt><font size=-1>MET
DST</font></tt>, or <tt><font size=-1>CET DST</font></tt>.&nbsp; Add to
this that the "S for summer" in the former two choices is often translated,
and then we have the French.
<p>The only good thing about geography is that most names can be translated
into geographical coordinates, and a mapping from coordinates to time zone
and daylight saving time rules is fairly easy to collect, but moderately
difficult to maintain.&nbsp; This work has been done, however, and is distributed
with most Unix systems these days, most notably the free ones, for some
value of "free".&nbsp; In order for a complete time representation to work
fully with its environment, access to this information is necessary.&nbsp;
The work on the <tt><font size=-1>LOCAL-TIME </font></tt>concept includes
an interface to the various databases available under most Unix systems.
<br>&nbsp;
<h2>
Perspective</h2>
An important part of the <tt><font size=-1>Y2K</font></tt> problem has
been that the information about the perspective on the time stored was
lost.&nbsp; Trivialities like the fact that people were born in the past,
bills were paid in the past and fall due in the future, deliveries will
be made in the future, etc, and most of the time, meaningful specifications
of time have hard boundaries that they cannot cross.&nbsp; Few people have
problems with credit cards that expire "02/02", say.&nbsp; This was very
obviously not 1902-02.
<br>The perspective we wring to time specifications usually last beyond
the particular time specified.
<p>When dealing with a particular time, it is therefore necessary to know,
or to be told, whether it refers to the past or the future, and whether
the vantage point is different from the present.&nbsp; If, for instance,
a delivery is due "10/15/99", and it fails to be delivered that day, only
a computer would assume that it was now due <tt><font size=-1>2099-10-15</font></tt>.&nbsp;
Unfortunately, there is no common practice in this area at all, and most
people are satisfied with a tacit assumption.&nbsp; That is in large part
what caused the <tt><font size=-1>Y2K</font></tt> problem to become so
enormously expensive to fix.&nbsp; Had the assumed, but now missing information
been available, the kinds of upgrades required would have been different,
and most likely much less expensive.
<p>There is more to the perspective than just past and future, however.&nbsp;
Most computer applications that are concerned with time are so with only
one particular time: the present.&nbsp; We all expect a log file to be
generated along with the events, and that it would be disastrous if the
computer somehow recorded a different time than the time at which an event
occurred, or came back to us and revised its testimony because it suddenly
remembered it better.&nbsp; Modern society is disproportionately dependent
on a common and coordinated concept of the present time, and we have increasingly
let computers take care of this perspective for us.&nbsp; Telephones and
computers, both voice and electronic radio broadcasts, watches, wall clocks,
the trusty old time clocks in factories where the workers depended on its
accuracy, they all portray this common concept of a coordinated understanding
of which time it is.&nbsp; And they all disagree slightly.&nbsp; A reportedly
Swiss saying goes: "A man with one clock knows the time.&nbsp; A man with
two clocks does not."
<p>Among the many unsolved problems facing society is an infrastructure
for time-keeping that goes beyond individual, uncoordinated providers,
and a time-keeping technology that actually works accurately and is so
widely available that the differences in opinion over what time it is can
be resolved authoritatively.&nbsp; The technology is actually here and
the infrastructure is almost available to everyone, but it is not used
by the multitude of purported sources of the current time.&nbsp; On the
Internet, <tt><font size=-1>NTP</font></tt> (the Network TIme Protocol)
keeps fully connected systems in sync, and most telecommunications and
energy providers have amazingly accurate clocks, but mere mortals are still
left with alarming inaccuracies.&nbsp; This fact alone has a tendency to
reduce the interest in accurate representation of time, for the obvious
reason that the more accurate the notation and representation, the less
trustworthy the value expressed.
<br>&nbsp;
<h2>
Calculations with Time</h2>
The notation for duration and periods bounded by one absolute position
in time and one duration described above have intuitive meaning, but when
pressed for actual meaning, suffer somewhat from the distressing effects
of political time.&nbsp; For instance, a period of one year that starts
<tt><font size=-1>1999-03-01</font></tt>
would end on <tt><font size=-1>2000-02-29</font></tt> or <tt><font size=-1>2000-03-01</font></tt>
with equal probability of being correct.&nbsp; More common problems occur
with the varying lengths of months, but those are also more widely understood
and the heuristics are in place to deal with them.
<p>Less obvious is the problem of adding one day to a particular time of
day.&nbsp; This was the original problem that spurred the development of
the <tt><font size=-1>LOCAL-TIME</font></tt> concept and its implementation.&nbsp;
In brief, the problem is to determine which two days of the year the day
is not 24 hours long.&nbsp; One good solution is to assume the day is 24
hours long and see if the new time has a different timezone than the original
time.&nbsp; If so, add the difference between the timezones to the internal
time.&nbsp; This, however, is not the trivial task it sounds like it should
be.
<p>The first complication is that none of the usual time functions can
report the absolute time that some timezone identifier will cause a change
in the value of timezone as applicable to the time of day.&nbsp; Resolving
this complications means that we do not have to test for a straddled timezone
boundary the hard way with every calculation, but could just compare with
the edge of the current timezone.&nbsp; Most software currently does this
the hard way, including the Unix "cron" scheduler.&nbsp; However, if we
accept the limitation that we can work with only one timezone at a time,
this becomes much less of a problem, so Unix and C people tend to ignore
this problem.
<p>The second complication is that there really is no way around working
with an internal time representation in any calculation -- attempts to
adjust elements of a decoded time generally fail, not only because programmers
are forgetful, but also because the boundary conditions are hard to enumerate.
<p>Most often, however, calculations fall into two mutually exclusive categories:
<ol>
<li>
calculations with the time of day possibly including days</li>

<li>
calculations with the date with no concept of a time of day</li>
</ol>
When time is represented internally in terms of seconds since an epoch,
only the former is easy -- the latter is irrevocably linked with all the
timezone problems.&nbsp; The latter may in particular be calculated without
reference to timezones at all, and indeed should be conducted in <tt><font size=-1>UTC</font></tt>.&nbsp;
As far as the author knows, there are no tools or packages available in
modern programming languages or environments that provide significant support
for calculations with dates apart from calculation with times of day --
these are usually deferred to the application-level, and appear not to
have been solved as far as the application programmer is concerned.
<br>&nbsp;
<h2>
Historic Randomness</h2>
The Roman tradition of using Ante Meridiem and Post Meridiem to refer to
the two halves have survived into English, despite the departure from the
custom of changing the day of the month at noon.&nbsp; The Meridiem therefore
has a very different role in modern usage than in ancient usage.&nbsp;
This legacy notation also carries a number system that is fairly unusual.&nbsp;
As seen from members of the 24-hour world, the order 12,1,2,...11,12,1,2,...,11
as mapped onto 0,1,2...,23 is not only confusing, it is nearly impossible
to make people believe that 13 hours have elapsed from 11 <tt><font size=-1>AM
</font></tt>to
12 <tt><font size=-1>AM</font></tt>.&nbsp; For instance, several Scandinavian
restaurants are open only 1 hour a day to tourists from the world of the
12-hour clock, but open 13 hours a day to natives of the world of the 24-hour
clock.
<p>The Roman tradition of starting the year in the month of March has also
been lost.&nbsp; Most agrarian societies were far more interested in the
onset of spring than in the winter solstice, even though various deities
were naturally celebrated when the sun returned&nbsp; Most calendars were
designed by people who made no particular effort to be general or accurate
outside their own lifetime or needs, but Julius Cæsar decided to move the
Roman calendar back two months, and thus it came to be known as the Julian
calendar.&nbsp; This means that month number 7, 8, 9, and 10 suddenly came
in as number 9, 10, 11, and 12, but kept their names: September, October,
November, December.&nbsp; This is of interest mostly to those who remember
their Latin but far more important was the decision to retain the leap
day in February.&nbsp; In the old calendar, the leap day was added at the
end of the year, as makes perfect sense, when the month was already short,
but now it is squeezed into the middle of the first quarter, complicating
all sorts of calculations, and affecting how much people work.&nbsp; In
the old days, the leap day was used as an extra day for the various fertility
festivities.&nbsp; You would just <i>have</i> to be a cæsar to find this
unappealing.
<p>The Gregorian calendar improved on the quadrennial leap years in the
Julian calendar by making only every fourth centennial a leap year, but
the decision was unexpectedly wise for a calendar decision.&nbsp; It still
is not accurate, so in a few thousand years, they may have to insert an
extra leap day the way we introduce leap seconds now, but the simplicity
of the scheme is quite amazing: a 400-year cycle not only starts <tt><font size=-1>2000-03-01</font></tt>
(as it did <tt><font size=-1>1600-03-01</font></tt>), it contains an even
number of weeks: 20,871.&nbsp; This means that we can make do with a single
400-year calculation for all time within the Gregorian calendar with respect
to days of week, leap days, etc.&nbsp; Pope Gregory XIII may well have
given a similar paper to this one to another unsuspecting audience that
probably also failed to appreciate the elegance of his solution., and 400
more years will pass before it is truly appreciated.
<p>Other than the unexpected elegance of the Gregorian calendar, the world
is now quite fortunate to have reached consensus on its calendars.&nbsp;
Other calendars are still used, but we now have a global reference calendar
with complete convertibility.&nbsp; This is great news for computers.&nbsp;
It is almost as great news as the complete intercurrency convertibility
that the monetary markets achieved only as late as 1992.&nbsp; Before that
time, you could wind up with a different amount of money depending on which
currencies you traded obscure currencies like the ruble through.&nbsp;
The same applied to calendars: not infrequently, you could wind up on different
dates according as you converted between calendar systems, similar to the
problem of adding a year to February 29 any year and then subtracting a
year.
<br>&nbsp;
<h2>
The <tt>LOCAL-TIME</tt> Concept</h2>
The groundwork should now have been laid for the introduction of the several
counter-intuitive decisions made in the design of the LOCAL-TIME concept
and its implementation.
<h3>
Time Elements as Fixnums</h3>
Unix time has the "advantage" that it is representable as a 32-bit machine
integer.&nbsp; It has the equal disadvantage of not working if the time
is not representable as a 32-bit machine integer, and thus can only represent
times in the interval <tt><font size=-1>1901-12-13T20:45:52/2038-01-19T03:14:07</font></tt>.&nbsp;
If we choose an unsigned machine integer, the interval is <tt><font size=-1>1970-01-01T00:00:00/2106-02-07T06:28:16</font></tt>.&nbsp;
The Common Lisp <tt><font size=-1>UNIVERSAL-TIME</font></tt> concept has
the disadvantage that it turned into a bignum on most 32-bit machines on
<tt><font size=-1>1934-01-10T13:37:04</font></tt>
and runs out of 32 bits two years earlier than Unix time, on <tt><font size=-1>2036-02-07T06:28:16</font></tt>.&nbsp;
I find these restrictions to be uncomfortable, regardless of whether there
are any 32-bit computers left in 2036 to share my pain.
<p>Bignum operations are generally far more expensive than fixnum operations,
and they have to be, regardless of how heavily the Common Lisp implementation
has optimized them.&nbsp; It therefore became a pronounced need to work
with fixnums in time-intensive applications.&nbsp; The decision fell on
splitting between days and seconds, which should require no particular
explanation, other than to point out that calculation with days regardless
of the time of day is now fully supported and very efficient.
<p>Because we are very close to the beginning of the next 400-year leap-year
cycle, thanks to Pope Gregory, day 0 is defined to be <tt><font size=-1>2000-03-01</font></tt>,
which much less arbitrary than other systems, but not obviously so.&nbsp;
Each 400-year cycle contains 146,097 days, so an arbitrary decision was
made to limit the day to a maximal negative value of -146,097, or <tt><font size=-1>1600-03-01</font></tt>.&nbsp;
This can be changed at the peril of accurately representing days that do
not belong to the calendar used at the time.&nbsp; No attempt has been
made to accurately describe dates not belonging to the Gregorian calendar,
as that is an issue resolvable only with reference to the borders between
countries and sometimes counties at the many different times throughout
history that monarchs, church leaders, or other power figures decided to
change to the Gregorian calendar.&nbsp; Catering to such needs is also
only necessary with dates prior to the conversion of the Russian calendar
to Gregorian, a decision made by Lenin as late as 1918, or any other conversion,
such as 1582 in most of Europe, 1752 in the United States, and even more
embarrassingly late in Norway.
<p>Not mention above is the need for millisecond resolution.&nbsp; Most
events on modern computers fall within the same second, so it is now necessary
to separate them by increasing the granularity of the clock representation.
This part is obviously optional in most time processing functions.
<p>The LOCAL-TIME concept therefore represents time as three disjoint fixnums:
<ol>
<li>
the number of days since (or until, when negative) <tt><font size=-1>2000-03-01</font></tt></li>

<li>
the number of seconds since the start of the day in Coordinated Universal
Time</li>

<li>
the number of milliseconds since the start of the second.</li>
</ol>
All numbers have origin 0.&nbsp; Only the number of days may be negative.
<p>The choice of epoch needs some more explanation.&nbsp; Conversion to
this system only requires subtracting two from the month and making January
and February part of the previous year.
<p>The moderate size of the fixnums allows us another enormous advantage
over customary ways to represent time.&nbsp; Since the leap year is now
always at the end of the year, it has no bearing on the decoding of the
year, month, day, and day-of-week of the date.&nbsp; By choosing this odd-looking
epoch, the entire problem with computing leap years and days evaporates.&nbsp;
This also means that a single, moderately large table of decoded date elements
may be pre-computed for 400 years, providing a tremendous speed-up over
the division-based calculations used by other systems.
<br>Similarly, a table of the decoded values of the 86400 possible seconds
in a day (86401 if we allow leap seconds) yields a tremendous speedup over
division-based calculations.&nbsp; (Depending on your processor and memory
speeds, a factor of 10 to 50 may be expected. for a complete decoding)
<br>&nbsp;
<h2>
Timezone Representation</h2>
David Olsen of Digital Equipment Corporation has laid down a tremendous
amount of work in collecting the timezones of the world and their daylight
saving time boundaries.&nbsp; Contrary to the Unix System V approach from
New Jersey (insert appropriate booing for best effect), which codifies
a daylight saving time regime only for the current year, and apply it to
all years, David Olsen's approach is to maintain tables of all the timezone
changes.&nbsp; A particular timezone thus has a fairly long table of periods
of applicability of the specific number of seconds of to add to get local
time.&nbsp; Each interval is represented by the start and end times of
the specific value, the specific value, a daylight saving time flag, and
the customary abbreviation of the timezone.&nbsp; On most Unix systems,
this is available in compiled files in <tt><font size=-1>/usr/share/zoneinfo/
</font></tt>under
names based on the continent and capital of the region in most cases, or
more general names in other cases.&nbsp; While not perfect, this is probably
a scheme good as any -- it is fairly easy to figure out which to use.&nbsp;
Usually, a table is also provided with geographic coordinates mapped to
the timezone file.
<p>For the timezone information, the <tt><font size=-1>LOCAL-TIME</font></tt>
concept implements a package, T<tt><font size=-1>Z</font></tt>, or <tt><font size=-1>TIMEZONE</font></tt>
in full, which contains symbols named after the files, whose values are
lazy-loaded timezone objects.&nbsp; Because the source files for the zoneinfo
files are generally not as available as the portably coded binary information,
the information are loaded into memory from the compiled files, thus maintaining
maximum compatibility with the other timezone functions on the system.
<p>In the <tt><font size=-1>LOCAL-TIME</font></tt> instances, the timezone
is represented as a symbol to aid in the ability to save literal time objects
in compiled Lisp files.&nbsp; The package TZ can easily be autoloaded in
systems that support such facilities, in order to reduce the load-order
complexity.
<p>In order to increase efficiency substantially once again, each timezone
object holds the last&nbsp; few references to timezone periods in it, in
order to limit the search time.&nbsp; Empirical studies of long-running
systems have showed that more than 98% of the lookups on a given timezone
were for time in the same period, with more than 80% of the remaining lookups
at the neighboring periods, so caching these values made ample sense.
<h3>
Efficiency Considerations in Table Storage</h3>
In order to store 146,072 entries for the days of a 400-year cycle with
the decoded year, month, day, and day-of-week and 86401 entries for the
seconds of a day with the decoded hour, minute and second efficiently,
various optimizations were employed.&nbsp; The naïve approach, to uses
lists, consumes approximately 6519K on a 32-bit machine.&nbsp; Due to their
overhead, vectors did worse.&nbsp; Since the decoded elements are small,
well-behaved unsigned integers, encoding them in bit fields within a fixnum
turns out to save a lot of memory:
<blockquote><tt>+----------+----+-----+---+&nbsp;&nbsp; +-----+------+------+</tt>
<br><tt>|&nbsp;&nbsp; yyyy&nbsp;&nbsp; | mm | day |dow|&nbsp;&nbsp; |hour
| min&nbsp; | sec&nbsp; |</tt>
<br><tt>+----------+----+-----+---+&nbsp;&nbsp; +-----+------+------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6</tt></blockquote>
This simple optimization meant 7 times more compact storage of the exact
same data, with significantly improved access times, to boot (depending
on processor and memory speeds as well as considerations for caching strategies,
a factor of 1.5 to 3 has been measured in production).
<p>Still, 909K of storage to keep tables of precomputed dates and times
may seem a steep price to pay for the improved performance.&nbsp; Unsurprisingly,
more empirical evidence confirmed that most dates decoded were in the same
century.&nbsp; Worst case over the next few years, we will access two centuries
frequently, but it is still a waste to store four full centuries.&nbsp;
A reduction to 100 years per table also meant the number of years were
representable in 7 bits, meaning that an specialized vector of type <tt><font size=-1>(UNSIGNED-BYTE
16)</font></tt> could represent them all.&nbsp; The day of week would be
lost in this optimization, but a specialized vector of type <tt><font size=-1>(UNSIGNED-BYTE
4)</font></tt> of the full length (146097) could hold them if a single
division to get the day of week was too expensive.&nbsp; It turns out that
the day of week is much less used than the other decoded elements, so the
specialized vector was dropped and an option included with the call to
the decoder to skip the day of week.
<br>Similarly, by representing only 12 hours in a specialized vector of
type <tt><font size=-1>(UNSIGNED-BYTE 16)</font></tt>, the hour would need
only 4 bits and the lookup could do the 12-hour shift in code.&nbsp; This
reduces the table memory needs to only 156K, and it is still faster than
access to the full list representation.&nbsp; This compaction yields almost
a factor 42 improvement over the naïve approach
<p>For completeness, the bit field layout is now simplified as follows.
<blockquote><tt>+-------+----+-----+&nbsp;&nbsp;&nbsp;&nbsp; +----+------+------+</tt>
<br><tt>| 0-100 |1-12| 1-31|&nbsp;&nbsp;&nbsp;&nbsp; |0-11| 0-59 | 0-59
|</tt>
<br><tt>+-------+----+-----+&nbsp;&nbsp;&nbsp;&nbsp; +----+------+------+</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;
6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6</tt></blockquote>
Decoding the day now means finding the 400-year cycle for the day of week,
the century within it for the table lookup, and adding together the values
of the centuries and the year from the table, which may be 100 to represent
January and February of the following century.&nbsp; All of this can be
done with very inexpensive fixnum operations for about <tt><font size=-1>2,939,600</font></tt>
years, after which the day will incur a bignum subtraction to bring it
into fixnum space for the next <tt><font size=-1>2,939,600</font></tt>
years.&nbsp; (This optimization has not actually been implemented.)
<br>&nbsp;
<h2>
Reading and Printing Time</h2>
Common Lisp is renowned for the ability to print and read back almost all
of its data types.&nbsp; The motivation for the <tt><font size=-1>LOCAL-TIME</font></tt>
concept included the ability to save human-readable timestamps in files,
as well as the ability to store literal time objects efficiently in compiled
Lisp files.&nbsp; The former has been accomplished through the use of the
reader macros.&nbsp; Ignoring all other possible uses of the <tt><font size=-1>@</font></tt>
character, it was chosen to be the reader macro for the full representation
of a <tt><font size=-1>LOCAL-TIME</font></tt> object.&nbsp; Considering
the prevalence of software that works with the <tt><font size=-1>UNIVERSAL-TIME</font></tt>
concept, especially in light of the lack of alternatives until now, <tt><font size=-1>#@</font></tt>
was chosen to be the reader macro for the <tt><font size=-1>UNIVERSAL-TIME</font></tt>
representation of a time object.&nbsp; This latter notation obviously loses
the original time zone information and any milliseconds.
<h3>
Timestring Syntax</h3>
The Lisp reader is instructed to parse a timestring following the reader
macro characters.&nbsp; Other functions may call <tt><font size=-1>PARSE-TIMESTRING</font></tt>
directly.&nbsp; Such a timestring follows I<tt><font size=-1>SO 8601</font></tt>
closely,&nbsp; but allows for a few enhancements and an additional option:
the ability to choose between comma and period for the fractional second
delimiter.
<p>Supported formats of the timestring syntax include
<ol>
<li>
absolute time with all elements, the default printed format</li>

<li>
absolute time with some elements omitted, as per <tt><font size=-1>ISO
8601</font></tt></li>

<li>
absolute time with date omitted, defaulting to the current</li>

<li>
absolute time with time omitted, defaulting to <tt><font size=-1>00:00:00Z</font></tt>.</li>

<li>
the most recent occurrence of a time of day, with a leading <tt><font size=-1>&lt;</font></tt>.</li>

<li>
the forthcoming occurrence of a time of day, with a leading <tt><font size=-1>></font></tt>.</li>

<li>
the time of day specified, but yesterday, with a leading <tt><font size=-1>-</font></tt>.</li>

<li>
the time of day specified, but tomorrow, with a leading <tt><font size=-1>+</font></tt>.</li>

<li>
the current time of day, with a single <tt><font size=-1>=</font></tt>.</li>
</ol>
Work in progress includes adding and subtracting a duration from the specified
time, such as the present, explaining the use of the <tt><font size=-1>=</font></tt>,
which is also needed to represent periods with one anchor at the present.&nbsp;
The duration syntax is, however, rife with assumptions that are fairly
hard to express concisely and to use without causing unexpected and unwanted
results.
<p>The standard syntax from <tt><font size=-1>ISO 8601</font></tt> is fairly
rich with options.&nbsp; These are mostly unsupported due to the ambiguity
they introduce.&nbsp; The goal with the timestring syntax is that positions
and periods of time shall be so easy to read and write in an information-preserving
syntax that there will be no need to cater to the information-losing formats
preferred by some only because of their attempt at similarity to their
spoken forms.
<h3>
Formatting Timestrings</h3>
Considering that the primary problem with time formats is randomness in
the order of the elements, the timestring formatter for <tt><font size=-1>LOCAL-TIME</font></tt>
objects allows no options in that regard, but allows elements to be omitted
as per the standard.&nbsp; The loss of 12-hour clocks will annoy a few
people for a time, but there is nothing quite like shaking a bad habit
for good.&nbsp; Of course, the persistent programmer will write his own
formatter, anyway, so the default should be made most sensible for representing
time in programs and in lisp-oriented input files.
<p>At present, the interface to the timestring formatter is well suited
for a call from <tt><font size=-1>FORMAT</font></tt> control strings with
the <tt><font size=-1>~//</font></tt> construct, and takes arguments a
follows:
<ol>
<li>
<tt>stream</tt> -- the stream to receive the formatter timestring</li>

<li>
<tt>local-time</tt> -- the <tt><font size=-1>LOCAL-TIME </font></tt>instance</li>

<li>
<tt>universal</tt> -- if true, ignore the timezone and use <tt><font size=-1>UTC</font></tt>.&nbsp;
This is the colon modifier.</li>

<li>
<tt>timezone</tt> -- if true, print a timezone specification at the end.&nbsp;
This is the atsign modifier.</li>

<li>
<tt>date-elements</tt> -- the number of elements of the date to write,
counted from the right.&nbsp; This is a number from 0 to 4 (the default
if omitted or <tt><font size=-1>NIL)</font></tt>.</li>

<li>
<tt>time-elements</tt> -- the number of elements of the time to write,
counted from the left.&nbsp; This is a number from 0 to 4 (the default
if omitted or <tt><font size=-1>NIL</font></tt>).</li>

<li>
<tt>date-separator</tt> -- the character to print between elements of the
date. If omitted or <tt><font size=-1>NIL,</font></tt> defaults to the
hyphen.</li>

<li>
<tt>time-separator</tt> -- the character to print between elements of the
time.&nbsp; If omitted or <tt><font size=-1>NIL</font></tt>, defaults to
the colon.&nbsp; This argument also applies to the timezone when it is
printed, and when it has a minute component.</li>

<li>
<tt>internal-separator</tt> -- the character to print between the date
and the time elements.&nbsp; May also be specified as the number 0, to
omit it entirely, which is the default if either the date or the time elements
are entirely omitted, or the letter <tt><font size=-1>T</font></tt> otherwise.</li>
</ol>

<h2>
Exported <tt>LOCAL-TIME</tt> Symbols</h2>

<ul>
<li>
<tt><font size=-1>LOCAL-TIME</font></tt></li>

<br>[Type]
<br>[Constructor] Arguments: (&amp;key universal internal unix (msec 0)
(zone 0).
<br>Produce a <tt><font size=-1>LOCAL-TIME</font></tt> instance from the
provided numeric time representation.
<li>
<tt><font size=-1>MAKE-LOCAL-TIME</font></tt></li>

<br>[Constructor] Arguments: (&amp;key day sec msec zone)
<li>
<tt><font size=-1>LOCAL-TIME-DAY</font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME-SEC</font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME-MSEC</font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME-ZONE</font></tt></li>

<br>[Accessors]
<li>
<tt><font size=-1>LOCAL-TIME&lt;</font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME&lt;=</font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME></font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME>=</font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME=</font></tt></li>

<li>
<tt><font size=-1>LOCAL-TIME/=</font></tt></li>

<br>[Functions] Comparison, just like <tt><font size=-1>STRING</font></tt>x.
<li>
<tt><font size=-1>LOCAL-TIME-ADJUST</font></tt></li>

<br>[Function]&nbsp; Arguments: (source timezone &amp;optional destination)
<br>Returns two values, the values of new <tt>day</tt> and <tt>sec</tt>
slots, or, if <tt>destination</tt> is a <tt><font size=-1>LOCAL-TIME </font></tt>instance,
fills the slots with the new values and returns the destination.
<li>
<tt><font size=-1>LOCAL-TIME-DESIGNATOR</font></tt></li>

<br>[Function] Convert a designator (real number) into a <tt><font size=-1>LOCAL-TIME</font></tt>
instance.
<li>
<tt><font size=-1>GET-LOCAL-TIME</font></tt></li>

<br>[Function] Return the current time as a <tt><font size=-1>LOCAL-TIME</font></tt>
instance.
<li>
<tt><font size=-1>ENCODE-LOCAL-TIME</font></tt></li>

<br>[Function] Arguments: (ms ss mm hh day month year &amp;optional timezone)
<br>Return a new <tt><font size=-1>LOCAL-TIME</font></tt> instance corresponding
to the specified time elements.
<li>
<tt><font size=-1>DECODE-LOCAL-TIME</font></tt></li>

<br>[Function] Argument: (local-time)
<br>Returns the decoded time as multiple values: ms, ss, mm, hh, day, month,
year, day-of-week, daylight-saving-time-p, timezone, and the customary
timezone abbreviation.
<li>
<tt><font size=-1>PARSE-TIMESTRING</font></tt></li>

<br>[Function] Arguments: (timestring &amp;key start end junk-allowed)
<br>Parse a timestring and return the corresponding <tt><font size=-1>LOCAL-TIME</font></tt>.
<li>
<tt><font size=-1>FORMAT-TIMESTRING</font></tt></li>

<br>[Function] Arguments: (stream local-time universal-p timezone-p date-elements
time-elements date-separator time-separator internal-separator)
<br>Produces on stream the timestring corresponding to the LOCAL-TIME with
the given options.
<li>
<tt><font size=-1>UNIVERSAL-TIME</font></tt></li>

<br>[Function] Return the <tt><font size=-1>UNIVERSAL-TIME</font></tt>
corresponding to the <tt><font size=-1>LOCAL-TIME</font></tt>.
<li>
<tt><font size=-1>INTERNAL-TIME</font></tt></li>

<br>[Function] Return the internal system time corresponding to the <tt><font size=-1>LOCAL-TIME</font></tt>.
<li>
<tt><font size=-1>UNIX-TIME</font></tt></li>

<br>[Function] Return the Unix time corresponding to the <tt><font size=-1>LOCAL-TIME</font></tt>.
<li>
<tt><font size=-1>TIMEZONE</font></tt></li>

<br>[Function] Arguments: (local-time &amp;optional timezone)
<br>Return as multiple values the time zone as the number of seconds east
of <tt><font size=-1>UTC</font></tt>, a boolean daylight-saving-p, the
customary abbreviation of the timezone, the starting time of this timezone,
and the ending time of this timezone
<li>
<tt><font size=-1>LOCAL-TIMEZONE</font></tt></li>

<br>[Function] Arguments: (adjusted-local-time &amp;optional timezone)
<br>Return the local timezone adjustment applicable at the already adjusted-local-time.&nbsp;
Used to reverse the effect of <tt><font size=-1>TIMEZONE</font></tt> and
<tt><font size=-1>LOCAL-TIME-ADJUST</font></tt>.
<li>
<tt><font size=-1>DEFINE-TIMEZONE</font></tt></li>

<br>[Macro] Arguments: (zone-name zone-file &amp;key load)
<br>Define zone-name (a symbol or a string) as a new timezone, lazy-loaded
from zone-file (a pathname designator relative to the zoneinfo directory
on this system).&nbsp; If load is true, load immediately.
<li>
<tt><font size=-1>*DEFAULT-TIMEZONE*</font></tt></li>

<br>[Variable] Holds the default timezone for all time operations needing
a default.</ul>

<h2>
<br>
Implementation, Source Code</h2>
The current implementation is somewhat dependent on Allegro CL 5.0 or higher,
but is available in the Naggum Software&nbsp; <a href="http://sourcery.naggum.no/lisp/local-time.html">Sourcery</a>&nbsp;
shortly after the conference.
<br>&nbsp;
<h2>
Conclusions</h2>

<ol>
<li>
The absence of a standard notation for time in Common Lisp required all
this work.</li>

<li>
The presence of International Standards for the representation of time
made it all a lot easier.</li>

<li>
Time basically has the most messed-up legacy you can imagine.</li>

<li>
Pope Gregory XIII made it a little easier on us all.</li>

<li>
Adoption of this proposal in Common Lisp systems and applications would
make time a lot easier for almost everyone involved, except users who cling
to the habits that caused the <tt><font size=-1>Y2K</font></tt> problems.</li>

<li>
This package is far from complete.</li>
</ol>

<h2>
<br>
Credits and Acknowledgments</h2>
This work has been funded by the author and by <tt><font size=-1>NHST</font></tt>,
publishers of Norway's financial daily, and <tt><font size=-1>TDN</font></tt>,
their electronic news agency, and has been a work in progress since late
1997.&nbsp; My colleagues and managers have been extremely supportive in
bringing this fundamental work to fruition.&nbsp; In particular, Linn Irén
Humlekjær and Erik Haugan suffered numerous weird proposals and false starts
but encouraged the conceptual framework and improved on the execution with
their ideas and by lending me an ear.&nbsp; My management line, consisting
of Ole-Martin Halden, Bjørn Hole, and
<br>Hasse Farstad, have encouraged the quality of the implementation and
were willing listeners to the many problems and odd ideas that preceded
the realization that this had to be done.
<p>The great guys at Franz Inc have helped with internal details in Allegro
CL and have of course made a wonderful Common Lisp environment to begin
with.&nbsp; Thanks in particular to Samantha Cichon and Anna McCurdy for
taking care of all the details and making my stays so carefree, and to
Liliana Avila for putting up with my total lack of respect for deadlines.
<p>Many thanks to Pernille Nylehn for reading and commenting on drafts,
nudging me towards finishing this work, and for taking care of my cat Xyzzy
so I could write this in peace and deliver it at LUGM '99 without worrying
about the little furball's constant craving for attention, but also without
both their warmth and comfort when computers simply refuse to behave rationally.
<br>&nbsp;
</body>
</html>
